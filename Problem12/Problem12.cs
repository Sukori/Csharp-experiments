/*
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

Ici, on accept les diviseurs depuis 1 jusqu'au nombre lui-même, on veut tous les diviseurs du nombre et on cherche le premier qui a plus de 500 diviseurs.

On a la formule n * (n+1)/2 qui calcule le n-ième nombre triangle

Bruteforce:
On prend la valeur du triangle qui démarre à 1
@ : On commence par compter les diviseurs du nombre triangle*(triangle+1)/2
Test si le compteur est > 500
    si oui, log le triangle
    si non
        on incrémente le triangle de 1
        @ : On recommence à compter les diviseurs du nouveau triangle*(triangle+1)/2

--> Cette façon de faire prend plus de 20 minutes !!!

On peut faire avec n*(n+1)/2 en séparant ainsi:
Diviseurs de (n/2) * diviseurs de (n+1) si n est pair
Diviseurs de (n) * diviseurs de ((n+1)/2) si n est impair

Chercher les diviseurs de deux petits nombres va plus vite que tous les diviseurs d'un gros nombre.

On peut aussi faire avec les prime factors.
Il faut juste savoir que ça donne un truc comme p1**a1 * p2**a2 * ... * pn**an qui est la suite de prime factors avec leurs puissances nous amène à:
(a1+1)*(a2+1)*...*(an+1) = nombre total de diviseurs du nombre. donc le Problème 3 Largest prime factor peut aider si on le modifie un peu pour garder tous les prime factors et pas juste le plus grand.

Merci Wolfram, je sais que le résultat est 2^2 × 3^2 × 5^3 × 7 × 11 × 13 × 17 = 76'576'500 le 12'375-ième triangular number

qui a 3*3*4*2*2*2*2 = 576 diviseurs

*/

using System;
using System.Numerics;

namespace ProjectEuler
{
    public class Problem12
    {
        public static void HighlyDivisibleTriangularNumber()
        {
            List<int> primeFactors = new() { 2, 3 };
            int divCount = 1;
            int[] triangular = new int[2] { 0, 0 };
            int triangularStep = 1;
            int result;
            int divCountTrig1, divCountTrig2;


            while (divCount < 500)
            {
                triangularStep++;
                triangular = MakeNombre(triangularStep);

                divCountTrig1 = CountDivisors(primeFactors, triangular[0], 0, 1);
                divCountTrig2 = CountDivisors(primeFactors, triangular[1], 0, 1);
                divCount = (divCountTrig1) * (divCountTrig2);
            }

            result = triangular[0] * triangular[1];

            Console.WriteLine($"On a fini pour {result} composé par {triangular[0]} x {triangular[1]} qui est le {triangularStep} ieme triangular et qui a {divCount} diviseurs");
        }

        private static int[] MakeNombre(int n)
        {
            if (n % 2 == 0) { return new int[] { n/2, n+1 }; }
            else { return new int[] { n, (n+1)/2 }; }
        }

        private static int CountDivisors(List<int> primeFactors, int n, int listPosition, int countFactors)
        {
            int currentCount = 0;
            while (n > 1 && listPosition < primeFactors.Count)
            {
                if (n % primeFactors[listPosition] == 0)
                {
                    currentCount++;
                    n /= primeFactors[listPosition];
                }
                else
                {
                    listPosition++;
                    countFactors *= currentCount + 1;
                    currentCount = 0;
                }
            }

            if (n > 1)
            {
                primeFactors.Add(n);
            }

            return countFactors *= 2;
        }
    }
}